import { z } from 'zod';

type Context<Meta extends z.ZodObject<any> | undefined> = {
    metadata: Meta extends z.ZodObject<any> ? z.infer<Meta> : undefined;
};
type PrependContext<C extends Context<any>, Args extends any[]> = [C, ...Args];
type DefaultContext = Context<undefined>;
type HasMeta<C extends Context<any>> = C extends Context<infer M> ? (M extends undefined ? false : true) : false;
type ExtractMeta<C extends Context<any>> = C extends Context<infer M> ? M : undefined;
type ContextRequiredFn<fn extends (...args: any[]) => any, C extends Context<any>, RequireMeta extends boolean = HasMeta<C>> = RequireMeta extends true ? (...args: Parameters<fn>) => {
    withMeta<M extends ExtractMeta<C>>(metadata: z.infer<M>): ContextRequiredFn<fn, C, false>;
} : ReturnType<fn>;

declare const ScopeTag: unique symbol;
type AnyFn<R> = (...args: any[]) => R;
type BidiType<fn extends AnyFn<any>, C extends Context<any>, type extends "server" | "client"> = fn & AsyncGenerator<Parameters<fn>, void, unknown> & BidiContextType<C, type>;
type BidiContextType<C extends Context<any>, type extends "server" | "client"> = type extends "client" ? {
    context: Promise<C>;
} : {
    context(context: C): Promise<void>;
};
type serverSignature<fn extends AnyFn<any>, C extends Context<any>> = (C extends DefaultContext ? <Meta extends z.ZodObject<any> | undefined>(context: {
    metadata?: Meta;
}) => serverSignature<fn, Context<Meta>> : fn) & {
    [ScopeTag]: "server";
};
type clientSignature<fn extends AnyFn<any>> = fn & {
    [ScopeTag]: "client";
};
type bidiSignature<fn extends AnyFn<void>, C extends Context<any>> = (C extends DefaultContext ? <Meta extends z.ZodObject<any> | undefined, Ack extends boolean = false>(context: {
    metadata?: Meta;
    ack?: Ack;
}) => bidiSignature<fn, Context<Meta>> : fn) & {
    [ScopeTag]: "bidi";
};
type RpcMethodDescriptor = {
    serviceType: "server" | "client" | "bidi";
    methodType: "unary" | "bidi";
    config?: {
        metadata: boolean;
        ack: boolean;
    };
};
declare function server<fn extends AnyFn<any>>(): serverSignature<(...args: Parameters<fn>) => Promise<ReturnType<fn>>, DefaultContext>;
declare function client<fn extends AnyFn<any>>(): clientSignature<(...args: Parameters<fn>) => Promise<ReturnType<fn>>>;
declare function bidi<fn extends AnyFn<void>>(..._: ReturnType<fn> extends void ? [] : ["Return type must be void"]): bidiSignature<(...args: Parameters<fn>) => Promise<void>, DefaultContext>;
type Unwrap<T, type extends "server" | "client", ContextChain extends boolean = false> = T extends serverSignature<infer F, infer C> ? C extends DefaultContext ? F : ContextChain extends true ? ContextRequiredFn<F, C> : (...args: PrependContext<C, Parameters<F>>) => ReturnType<F> : T extends clientSignature<infer F> ? F : T extends bidiSignature<infer F, infer C> ? BidiType<F, C, type> : never;
type ServerFn<T, IncludeBidi extends boolean = true, ContextChain extends boolean = false> = {
    [K in keyof T as T[K] extends serverSignature<AnyFn<any>, any> | (IncludeBidi extends true ? bidiSignature<AnyFn<void>, any> : never) ? K : never]: Unwrap<T[K], "server", ContextChain>;
};
type ClientFn<T, IncludeBidi extends boolean = true> = {
    [K in keyof T as T[K] extends clientSignature<AnyFn<any>> | (IncludeBidi extends true ? bidiSignature<AnyFn<void>, any> : never) ? K : never]: Unwrap<T[K], "client">;
};

declare const ServiceNameTag: unique symbol;
interface ServiceInstance<N extends string = string> {
    readonly [ServiceNameTag]: N;
}
type AbstractServiceClass<N extends string = string> = abstract new (...args: never) => ServiceInstance<N>;
declare class ServiceImpl<T extends AbstractServiceClass, Type extends "server" | "client"> {
    readonly implementation: any;
    readonly type: Type;
    readonly serviceClass: T;
    readonly serviceClassInstance: InstanceType<T>;
    constructor(implementation: any, type: Type, serviceClass: T);
    methods(): Record<string, RpcMethodDescriptor>;
}
declare function Service<N extends string>(name: N): (abstract new () => {
    readonly [ServiceNameTag]: N;
}) & {
    serviceName: N;
    Server<T extends AbstractServiceClass, Impl extends ServerFn<InstanceType<T>, false>>(this: T, implementation: Impl): ServiceImpl<T, "server">;
    Client<T extends AbstractServiceClass, Impl extends ClientFn<InstanceType<T>, false>>(this: T, implementation: Impl): ServiceImpl<T, "client">;
};
type ServiceNameOf<T extends ServiceImpl<any, any>> = T extends ServiceImpl<infer ServiceClass, any> ? InstanceType<ServiceClass>[typeof ServiceNameTag] : never;
type ServiceCallable<T> = T extends ServiceImpl<infer S, infer Mode> ? Mode extends "server" ? ClientFn<InstanceType<S>> : ServerFn<InstanceType<S>, true, true> : never;

declare function createGrpcClient<T extends ServiceImpl<any, "client">[]>(address: string, ...serviceImpls: T): Promise<{
    [I in T[number] as ServiceNameOf<I>]: ServiceCallable<I>;
}>;

declare function createGrpcServer<T extends ServiceImpl<any, "server">[]>(port: number, ...serviceImpls: T): Promise<{
    [I in T[number] as ServiceNameOf<I>]: ServiceCallable<I>;
}>;

export { Service, bidi, client, createGrpcClient, createGrpcServer, server };
